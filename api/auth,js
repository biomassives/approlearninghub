// api/auth.js
const { sign } = require('jsonwebtoken');
const { createError } = require('./utils/errors');
const { db } = require('./utils/db');

// Secret keys (should be loaded from environment variables in production)
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-jwt-key';
const REFRESH_SECRET = process.env.REFRESH_SECRET || 'your-refresh-secret-key';
const SERVICE_ROLE_KEY = process.env.SERVICE_ROLE_KEY || 'your-service-role-key';

// Token expiration times
const ACCESS_TOKEN_EXPIRY = '1h';
const REFRESH_TOKEN_EXPIRY = '7d';

/**
 * Handle authentication requests
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
const authHandler = async (req, res) => {
  try {
    const { grant_type, refresh_token, email, password } = req.body;
    
    // Validate request
    if (!grant_type) {
      throw createError(400, 'Grant type is required');
    }
    
    // Handle different grant types
    switch (grant_type) {
      case 'client_credentials':
        return handleClientCredentials(req, res);
      
      case 'refresh_token':
        if (!refresh_token) {
          throw createError(400, 'Refresh token is required');
        }
        return handleRefreshToken(req, res, refresh_token);
      
      case 'password':
        if (!email || !password) {
          throw createError(400, 'Email and password are required');
        }
        return handlePasswordGrant(req, res, email, password);
      
      default:
        throw createError(400, `Unsupported grant type: ${grant_type}`);
    }
  } catch (error) {
    console.error('Auth error:', error);
    
    const status = error.status || 500;
    const message = error.message || 'Internal server error';
    
    res.status(status).json({
      error: true,
      message
    });
  }
  };


/**
 * Compare plain password with hashed password
 * @param {string} plainPassword - Plain text password
 * @param {string} hashedPassword - Hashed password
 * @returns {Promise<boolean>} - Comparison result
 */
const comparePassword = async (plainPassword, hashedPassword) => {
  // This is a simplified version. In production, use bcrypt or similar
  // For demo purposes only - NOT secure for production
  return plainPassword === hashedPassword;
};

/**
 * Verify JWT token
 * @param {string} token - JWT token
 * @param {string} secret - Secret key
 * @returns {Object} - Decoded token payload
 */
const verify = (token, secret) => {
  try {
    return require('jsonwebtoken').verify(token, secret);
  } catch (error) {
    throw createError(401, 'Invalid or expired token');
  }
};

// Export handlers
module.exports = authHandler;


/**
 * Handle client credentials grant type
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
const handleClientCredentials = async (req, res) => {
  // Check for service role key
  const serviceKey = req.headers['x-service-key'];
  
  if (serviceKey !== SERVICE_ROLE_KEY) {
    throw createError(401, 'Invalid service key');
  }
  
  // Generate token pair
  const tokenPair = generateTokenPair({
    role: 'service',
    type: 'client_credentials'
  });
  
  res.json(tokenPair);
};

/**
 * Handle refresh token grant type
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 * @param {string} refreshToken - Refresh token
 */
const handleRefreshToken = async (req, res, refreshToken) => {
  try {
    // Verify refresh token
    const decoded = verify(refreshToken, REFRESH_SECRET);
    
    // Generate new token pair
    const tokenPair = generateTokenPair({
      userId: decoded.userId,
      role: decoded.role,
      email: decoded.email,
      type: 'refresh'
    });
    
    res.json(tokenPair);
  } catch (error) {
    throw createError(401, 'Invalid or expired refresh token');
  }
};

/**
 * Handle password grant type (user login)
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 * @param {string} email - User email
 * @param {string} password - User password
 */
const handlePasswordGrant = async (req, res, email, password) => {
  // Find user
  const user = await db.users.findOne({ email });
  
  if (!user) {
    throw createError(401, 'Invalid credentials');
  }
  
  // Verify password (using a secure hash comparison)
  const isValid = await comparePassword(password, user.password);
  
  if (!isValid) {
    throw createError(401, 'Invalid credentials');
  }
  
  // Generate token pair
  const tokenPair = generateTokenPair({
    userId: user.id,
    role: user.role,
    email: user.email,
    type: 'password'
  });
  
  res.json({
    ...tokenPair,
    user: {
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role
    }
  });
};

/**
 * Generate access and refresh token pair
 * @param {Object} payload - Token payload
 * @returns {Object} - Token pair
 */
const generateTokenPair = (payload) => {
  // Create access token
  const accessToken = sign(
    { ...payload, tokenType: 'access' },
    JWT_SECRET,
    { expiresIn: ACCESS_TOKEN_EXPIRY }
  );
  
  // Create refresh token
  const refreshToken = sign(
    { ...payload, tokenType: 'refresh' },
    REFRESH_SECRET,
    { expiresIn: REFRESH_TOKEN_EXPIRY }
  );
  
  // Calculate expiry time in seconds
  const expiresIn = 3600; // 1 hour in seconds
  
  return {
    access_token: accessToken,
    refresh_token: refreshToken,
    token_type: 'Bearer',
    expires_in: expiresIn
  };


};
  